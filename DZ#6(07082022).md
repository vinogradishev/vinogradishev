#### ДЗ №6 "Блокировки"
##### _1.Настроил время ожидания блокировки на 200 мс и включил журнал:_ 
> ALTER SYSTEM SET deadlock_timeout TO 200; 

> ALTER SYSTEM SET log_lock_waits TO on;
>> ![alt tag](https://github.com/vinogradishev/vinogradishev/blob/a2796256f116afa48ba3ee0d264aec2a62c4de7b/Setlockdeadlock.png)

- Запустил 2 транзакции, в первой сделал UPDATE, а во второй TRUNCATE, запись об ожидании блокировки появилась в журнале.
>> ![alt tag](https://github.com/vinogradishev/vinogradishev/blob/a2796256f116afa48ba3ee0d264aec2a62c4de7b/blockRE_AE.png)
>> ![alt tag](https://github.com/vinogradishev/vinogradishev/blob/a2796256f116afa48ba3ee0d264aec2a62c4de7b/wait200ms.png)

##### _2.Сделал тестовую таблицу, в 3 сессиях начал транзакцию и UPDATE одной и тойже строки_ 
> Всего у меня три процесса: 1256, 1261, 1265, в них три транзакции: 741, 742, 743 соответственно.
>> ![alt tag](https://github.com/vinogradishev/vinogradishev/blob/a2796256f116afa48ba3ee0d264aec2a62c4de7b/lock.png)

##### _3.Создал в таблице три записи, смоделировал ситуацию взаимной блокировки_ 
> Всего у меня три процесса: 1912, 1915, 1951, в них три транзакции, получился такой круг:
>> 1 транзакция ждёт 3 транзакцию, 2 тразакция ждёт 1, а 3 транзакция ждёт 2 транзакцию.

>> Последовательно были введены следующие команды (s - сессия):
>> s1:BEGIN;
>> 
>> s1:UPDATE test SET c1 = 10 WHERE c1 = 1;
>> 
>> s2:BEGIN;
>> 
>> s2:UPDATE test SET c2 = 20 WHERE c1 = 2;
>> 
>> s3:BEGIN;
>> 
>> s3:UPDATE test SET c1 = 30 WHERE c1 = 3;
>> 
>> s1:UPDATE test SET c1 = 300 WHERE c1 = 3; - зависло в ожидании
>> 
>> s2:UPDATE test SET c1 = 100 WHERE c1 = 1; - зависло в ожидании
>> 
>> s3:UPDATE test SET c1 = 200 WHERE c1 = 2; - зависло в ожидании
>> ![alt tag](https://github.com/vinogradishev/vinogradishev/blob/a2796256f116afa48ba3ee0d264aec2a62c4de7b/deadlock.png)

##### _4.Заполнил таблицу 500000 строк, попробовал заблокировать обе транзакции_ 
> У меня не получилось смоделировать такое, хотя я предполагал что такое возможно, если таблицы большие и две транзакции одновременно будут работать над ними, но по факту они работают по очереди, и вторая транзакция начинат работать только когда первая закончит. Вот если таблицы две тогда легко:
>> ![alt tag](https://github.com/vinogradishev/vinogradishev/blob/a2796256f116afa48ba3ee0d264aec2a62c4de7b/SELFdeadlock.png)
